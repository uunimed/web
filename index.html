<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>High-End Abstract Waves</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505; /* ღრმა შავი ფონი */
            font-family: sans-serif;
        }
        canvas {
            display: block;
        }
        /* დამატებითი overlay ვინეტისთვის (კუთხეების დაბნელება) */
        .vignette {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background: radial-gradient(circle, rgba(0,0,0,0) 50%, rgba(0,0,0,0.8) 100%);
        }
    </style>
</head>
<body>
    <div class="vignette"></div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script type="x-shader/x-vertex" id="vertexshader">
        attribute float scale;
        void main() {
            vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
            gl_PointSize = scale * ( 300.0 / - mvPosition.z );
            gl_Position = projectionMatrix * mvPosition;
        }
    </script>

    <script type="x-shader/x-fragment" id="fragmentshader">
        uniform vec3 color;
        void main() {
            if ( length( gl_PointCoord - vec2( 0.5, 0.5 ) ) > 0.475 ) discard;
            gl_FragColor = vec4( color, 1.0 );
        }
    </script>

    <script>
        let SEPARATION = 100, AMOUNTX = 50, AMOUNTY = 50;
        let container;
        let camera, scene, renderer;
        let particles, count = 0;
        let mouseX = 0, mouseY = 0;
        let windowHalfX = window.innerWidth / 2;
        let windowHalfY = window.innerHeight / 2;
        
        // ფერების ცვლადები
        let hue = 0;

        init();
        animate();

        function init() {
            container = document.createElement('div');
            document.body.appendChild(container);

            // კამერის პარამეტრები (ხედვის კუთხე და პოზიცია)
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 10000);
            camera.position.z = 1000;
            camera.position.y = 300;

            scene = new THREE.Scene();

            // ნაწილაკების (ხაზების წერტილების) რაოდენობა
            const numParticles = AMOUNTX * AMOUNTY;
            const positions = new Float32Array(numParticles * 3);
            const scales = new Float32Array(numParticles);

            let i = 0, j = 0;

            // ბადის შექმნა
            for (let ix = 0; ix < AMOUNTX; ix++) {
                for (let iy = 0; iy < AMOUNTY; iy++) {
                    positions[i] = ix * SEPARATION - ((AMOUNTX * SEPARATION) / 2); // x
                    positions[i + 1] = 0; // y (სიმაღლე, რომელსაც ანიმაციაში შევცვლით)
                    positions[i + 2] = iy * SEPARATION - ((AMOUNTY * SEPARATION) / 2); // z
                    scales[j] = 1;
                    i += 3;
                    j++;
                }
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('scale', new THREE.BufferAttribute(scales, 1));

            // მასალა - აქ ვიყენებთ წერტილებს, რომლებიც ქმნიან ხაზოვან ილუზიას
            // უფრო "სუფთა" ხაზებისთვის შეგვიძლია გამოვიყენოთ PointsMaterial
            const material = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 3, // წერტილის ზომა
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending // მანათობელი ეფექტი
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true }); // მაღალი ხარისხის რენდერი
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            container.appendChild(renderer.domElement);

            // მაუსის მოძრაობაზე რეაგირება (პარალაქსის ეფექტი)
            document.addEventListener('mousemove', onDocumentMouseMove, false);
            document.addEventListener('touchstart', onDocumentTouchStart, false);
            document.addEventListener('touchmove', onDocumentTouchMove, false);
            window.addEventListener('resize', onWindowResize, false);
        }

        function onWindowResize() {
            windowHalfX = window.innerWidth / 2;
            windowHalfY = window.innerHeight / 2;
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onDocumentMouseMove(event) {
            mouseX = event.clientX - windowHalfX;
            mouseY = event.clientY - windowHalfY;
        }

        function onDocumentTouchStart(event) {
            if (event.touches.length === 1) {
                event.preventDefault();
                mouseX = event.touches[0].pageX - windowHalfX;
                mouseY = event.touches[0].pageY - windowHalfY;
            }
        }

        function onDocumentTouchMove(event) {
            if (event.touches.length === 1) {
                event.preventDefault();
                mouseX = event.touches[0].pageX - windowHalfX;
                mouseY = event.touches[0].pageY - windowHalfY;
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            render();
        }

        function render() {
            // კამერის ნაზი მოძრაობა მაუსის მიხედვით
            camera.position.x += (mouseX - camera.position.x) * 0.05;
            camera.position.y += (-mouseY + 200 - camera.position.y) * 0.05;
            camera.lookAt(scene.position);

            const positions = particles.geometry.attributes.position.array;
            const scales = particles.geometry.attributes.scale.array;

            // ტალღოვანი მოძრაობის მათემატიკა
            let i = 0, j = 0;
            for (let ix = 0; ix < AMOUNTX; ix++) {
                for (let iy = 0; iy < AMOUNTY; iy++) {
                    // სინუსოიდური ტალღების კომბინაცია რთული რელიეფისთვის
                    positions[i + 1] = (Math.sin((ix + count) * 0.3) * 50) +
                                       (Math.sin((iy + count) * 0.5) * 50);
                    
                    // ზომის ცვლილება სიღრმის მიხედვით
                    scales[j] = (Math.sin((ix + count) * 0.3) + 1) * 2 +
                                (Math.sin((iy + count) * 0.5) + 1) * 2;
                    i += 3;
                    j++;
                }
            }

            particles.geometry.attributes.position.needsUpdate = true;
            particles.geometry.attributes.scale.needsUpdate = true;

            // ფერების დინამიური ცვლილება (HSL)
            hue += 0.002; // ფერის ცვლილების სიჩქარე
            if (hue > 1) hue = 0;
            
            // ფერის დაყენება: აქ ვიყენებთ მოცისფრო-მწვანე სპექტრს (როგორც თქვენს ფოტოზეა)
            // შეგიძლიათ შეცვალოთ setHSL პარამეტრები სხვა ფერებისთვის
            // (hue, saturation, lightness)
            particles.material.color.setHSL(hue, 0.8, 0.6); 

            count += 0.05; // ტალღის სიჩქარე
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
